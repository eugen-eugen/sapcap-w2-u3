const {
  Components: { DATA_DELETE_HANDLER, DATA_READ_HANDLER, DATA_CREATE_HANDLER, DATA_UPDATE_HANDLER }
} = require('@sap/odata-server')

const { getOnCond } = require('../../../../../lib/cds-sql').onCond
const { isStreaming } = require('./stream')

const _isFunctionInvocation = req =>
  req.getUriInfo().getLastSegment().getFunction || req.getUriInfo().getLastSegment().getFunctionImport

const _getTypeName = edmRef =>
  edmRef.getProperty
    ? edmRef
      .getProperty()
      .getType()
      .getName()
    : edmRef.getType().getName()

/**
 * The key predicates or function parameters will contain the keys and values for this request.
 * Combine all key value pairs into one object.
 * @param parameters
 * @returns {Object}
 * @private
 */
const _getParamData = parameters => {
  const paramData = {}

  for (const segmentParam of parameters) {
    const edmRef = segmentParam.getEdmRef()
    const typeName = _getTypeName(edmRef)

    // Convert any integer type into numeric values.
    paramData[edmRef.getName()] = typeName.startsWith('Int') ? Number(segmentParam.getText()) : segmentParam.getText()
  }

  return paramData
}

// works only for custom on condition working on keys with '=' operator
// and combination of multiple conditions connected with 'and'
const _addKeysToData = (navSourceKeyValues, onCondition, data) => {
  for (const key of Object.keys(navSourceKeyValues)) {
    // find index of source column
    const sourceIndex = onCondition.findIndex(e => e.ref && e.ref[0] === 'source' && e.ref[1] === key)
    if (sourceIndex === -1 && key === 'IsActiveEntity') {
      data[key] = false
    } else {
      // if '=' follows on index, the target columns comes next
      const {
        ref: [, target]
      } = onCondition[sourceIndex + 1] === '=' ? onCondition[sourceIndex + 2] : onCondition[sourceIndex - 2]
      data[target] = navSourceKeyValues[key]
    }
  }
}

const _addForeignKeys = (service, req, data) => {
  const pathSegments = req.getUriInfo().getPathSegments()
  // retrieve keys/values from the path segment representing the navigation source
  const navSourceSegment = pathSegments[pathSegments.length - 2]
  const navSourceKeyValues = _getParamData(navSourceSegment.getKeyPredicates())

  // retrieve relevant foreign key properties of the target entity, including the corresponding source key properties
  const navProperty = req
    .getUriInfo()
    .getLastSegment()
    .getNavigationProperty()

  if (navProperty.getPartner()) {
    const refConstraints = navProperty.getPartner().getReferentialConstraints()

    // set value of foreign key properties as specified in the navigation source segment
    for (const key of Object.keys(navSourceKeyValues)) {
      const refConstraint = [...refConstraints].find(r => r[1].constraint.referencedProperty === key)
      // exclude source keys if they cannot be matched (e.g. isActiveEntity in draft scenario)
      if (refConstraint) {
        data[refConstraint[0]] = navSourceKeyValues[key]
      }
    }
  } else {
    const entityName = navSourceSegment
      .getEntitySet()
      .getEntityType()
      .getFullQualifiedName()
      .toString()
    const navigationName = navProperty.getName()
    const navigationDefinition = service.model.definitions[entityName].elements[navigationName]
    const onCondition = getOnCond(navigationDefinition, navigationName, service.model, 'target', 'source')

    _addKeysToData(navSourceKeyValues, onCondition, data)
  }
}

const _getFunctionParameters = (lastSegment, keyValues) => {
  const functionParameters = lastSegment.getFunctionParameters()
  const paramValues = _getParamData(functionParameters)

  // Working assumption for the case of name collisions: take the entity's key
  for (const key of Object.keys(keyValues)) {
    paramValues[key] = keyValues[key]
  }
  return paramValues
}

// REVISIT: copied from BaseContext
const _fillKeyValues = (keyValues, data) => {
  for (const key of Object.keys(keyValues)) {
    data[key] = keyValues[key]
  }
}

/**
 * Get data from odata-v4.
 * READ and DELETE work are retrieved from URL; CREATE and UPDATE from body.
 * For function invocations the URL parameters are set as data.
 * For CREATE and UPDATE annotated columns can be mixed in.
 *
 * @param {string} component - odata-v4 component which processes this request.
 * @param req
 * @returns {Object}
 * @private
 */
const getData = (component, service, req) => {
  const segments = req.getUriInfo().getPathSegments()
  const lastSegment = req.getUriInfo().getLastSegment()
  const streaming = isStreaming(segments)
  const keyPredicates = streaming ? segments[segments.length - 2].getKeyPredicates() : lastSegment.getKeyPredicates()
  const keyValues = _getParamData(keyPredicates)

  if (component === DATA_READ_HANDLER && _isFunctionInvocation(req)) {
    return _getFunctionParameters(lastSegment, keyValues)
  }

  if (component === DATA_DELETE_HANDLER || component === DATA_READ_HANDLER) {
    return keyValues
  }

  // Use identifier from URL instead of body
  let data = req.getBody() || {}

  if (streaming) {
    const dataObj = {}
    dataObj[lastSegment.getProperty().getName()] = data
    data = dataObj
  }

  // Only to be done for post via navigation
  if (component === DATA_CREATE_HANDLER && lastSegment.getKind() === 'NAVIGATION.TO.MANY') {
    _addForeignKeys(service, req, data)
  }

  if (component === DATA_UPDATE_HANDLER || component === DATA_CREATE_HANDLER) {
    _fillKeyValues(keyValues, data)
  }

  return data
}

module.exports = {
  getData
}
