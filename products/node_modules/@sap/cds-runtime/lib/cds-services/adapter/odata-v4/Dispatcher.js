const serviceFactory = require('../../services/service_factory')
const OData = require('./OData')

const { ensureNoDraftsSuffix } = require('../../services/utils/draftUtils')

class Dispatcher {
  /**
   * Constructs an Dispatcher for OData service.
   * New OData services will be created in case of extensibility.
   *
   * @param odata
   */
  constructor (odata) {
    this._odata = odata
  }

  _enableMtx () {
    if (!this._extMap) {
      this._extMap = new Map()
      global.cds.mtx.eventEmitter.on(global.cds.mtx.events.TENANT_UPDATED, async tenantId => {
        this._extMap.delete(tenantId)
      })
    }
  }

  // REVISIT: Why do we store the entity with _drafts???
  _ensureNoDraftsSuffixIfEntity (entity) {
    if (entity) return ensureNoDraftsSuffix(entity)
  }

  _addCustomHandlers (service) {
    service.impl(srv => {
      for (const before of this._odata._cdsService._handlers.before._handlers) {
        if (!before.handler.isDefault) {
          srv.before(before.event, this._ensureNoDraftsSuffixIfEntity(before.entity), before.handler)
        } else {
          break
        }
      }
      for (const on of this._odata._cdsService._handlers.on._handlers) {
        if (!on.handler.isDefault) {
          srv.on(on.event, this._ensureNoDraftsSuffixIfEntity(on.entity), on.handler)
        } else {
          break
        }
      }
      for (const after of this._odata._cdsService._handlers.after._handlers) {
        if (!after.handler.isDefault) {
          srv.after(after.event, this._ensureNoDraftsSuffixIfEntity(after.entity), after.handler)
        } else {
          break
        }
      }
    })
  }

  async _getProtocolAndService (tenantId) {
    const csn = await global.cds.mtx.getCsn(tenantId)

    if (global.cds.env.features && global.cds.env.features.snapi) {
      this._odata._options.reflectedModel = global.cds.linked(global.cds.compile.for.odata(csn, { version: 'v4' }))
    } else {
      this._odata._options.reflectedModel = global.cds.linked(global.cds.compile.for.odata(csn))
    }

    const service = serviceFactory(csn, this._odata._options)
    this._addCustomHandlers(service)
    service._isExtended = true
    const edm = global.cds.compile.to.edm(csn, { service: service.options.service, version: 'v4' })
    const odata = new OData(edm, csn, this._odata._options)
    odata.addCDSServiceToChannel(service)

    return odata
  }

  async _processExtTenant (req, res) {
    try {
      if (!this._extMap.has(req.authInfo.identityZone)) {
        this._extMap.set(req.authInfo.identityZone, await this._getProtocolAndService(req.authInfo.identityZone))
      }

      this._extMap.get(req.authInfo.identityZone).process(req, res)
    } catch (err) {
      res.status(500).send({
        error: {
          code: 'null',
          message: 'Internal Server Error'
        }
      })
    }
  }

  /**
   * Dispatch request in case of extensibility to other odata adapters.
   * @private
   */
  dispatch (req, res) {
    if (global.cds.mtx && Object.keys(global.cds.mtx).length !== 0 && req.authInfo && req.authInfo.identityZone) {
      this._enableMtx()
      this._processExtTenant(req, res)
    } else {
      this._odata.process(req, res)
    }
  }

  /**
   * Return service middleware, which can be used by node server, express, connect, ...
   * @returns {function}
   */
  getService () {
    return (req, res) => {
      this.dispatch(req, res)
    }
  }
}

module.exports = Dispatcher
